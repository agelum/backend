---
description: Guide for using @agelum/backend - a reactive database library for Drizzle ORM with tRPC integration
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
alwaysApply: false
---

# @agelum/backend Library Usage Guide

This document provides guidance on using the `@agelum/backend` library - a reactive database library that transforms Drizzle + tRPC setups into reactive, real-time systems with minimal configuration.

## Overview

`@agelum/backend` provides:
- **Zero Configuration**: Single config file with table relations
- **Instant Cache**: Shows cached data immediately, revalidates smartly
- **Real-time Sync**: Built-in Server-Sent Events (SSE) for cache invalidation
- **Smart Invalidation**: Only invalidates relevant queries based on relations
- **Type Safety**: 100% automatic type safety with tRPC integration

## Import Paths

The library has three main entry points. Always use the correct import path:

```typescript
// Server-side only (Node.js, API routes, background jobs)
import {
  createReactiveDb,
  defineReactiveFunction,
  createReactiveRouter,
  createSSEStream,
  broadcastInvalidation,
  acknowledgeEvent,
  RedisProvider,
  MemoryProvider,
  // Transaction types (optional, for explicit typing)
  type TransactionOptions,
  type TransactionConfig,
  type TransactionReplicationMode,
} from "@agelum/backend/server";

// Client-side only (React components)
import {
  ReactiveProvider,
  TrpcReactiveProvider,
  useReactive,
  useReactiveQuery,
  useReactiveConnection,
  initializeReactiveClient,
  LocalStorageProvider,
} from "@agelum/backend/client";

// tRPC-specific utilities
import { ... } from "@agelum/backend/trpc";
```

## Core Concepts

### 1. Reactive Functions

Reactive functions are the building blocks. They work both standalone (server-side) AND via tRPC.

**Key Properties:**
- `name`: Becomes the cache key AND tRPC procedure name (e.g., `"users.getAll"`)
- `input`: Zod schema for input validation
- `dependencies`: Array of table names this function reads from (for cache invalidation)
- `handler`: Receives `{ input, db }` context - use `db.db` to access the underlying Drizzle instance

```typescript
import { defineReactiveFunction } from "@agelum/backend/server";
import { z } from "zod";

export const getUsers = defineReactiveFunction({
  name: "users.getAll",  // üîë Cache key + tRPC procedure name

  input: z.object({
    companyId: z.string(),
    limit: z.number().optional().default(50),
  }),

  dependencies: ["user"],  // Tables this function reads from

  handler: async ({ input, db }) => {
    // Use db.db to access the Drizzle instance
    return db.db.query.users.findMany({
      where: (users, { eq }) => eq(users.companyId, input.companyId),
      limit: input.limit,
    });
  },
});
```

**Nested Names Work:**
```typescript
export const getUserProfile = defineReactiveFunction({
  name: "users.profile.getDetailed",  // Creates nested tRPC procedure
  input: z.object({ userId: z.string() }),
  dependencies: ["user", "profile", "preferences"],
  handler: async ({ input, db }) => {
    return db.db.query.users.findFirst({
      where: (users, { eq }) => eq(users.id, input.userId),
      with: { profile: true, preferences: true },
    });
  },
});
```

**Cache per Function (opt-in):**
```typescript
export const getUsers = defineReactiveFunction({
  name: "users.getAll",
  input: z.object({ companyId: z.string() }),
  dependencies: ["user"],
  cacheEnabled: true,
  handler: async ({ input, db }) => {
    return db.db.query.users.findMany({
      where: (users, { eq }) => eq(users.companyId, input.companyId),
    });
  },
});
```
Cache is opt-in per function via `cacheEnabled: true` or `cache.enabled: true`.

### 2. Server-Side Execution (Without tRPC)

Use `.execute(input, db)` for API routes, background jobs, webhooks, etc:

```typescript
import { getUsers, createUser } from "../functions/users";
import { db } from "../db";

// In an API route
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const companyId = searchParams.get("companyId")!;

  // ‚úÖ Direct server-side execution
  const users = await getUsers.execute({ companyId, limit: 20 }, db);
  return Response.json({ users });
}

// In a background job
export async function generateDailyStats() {
  const companies = await db.db.query.companies.findMany();
  for (const company of companies) {
    const users = await getUsers.execute({ companyId: company.id }, db);
    // Process stats...
  }
}
```

### 3. tRPC Router Integration

Create tRPC routers that automatically use function names as procedure names:

```typescript
import { createReactiveRouter } from "@agelum/backend/server";
import { getUsers, createUser, getUserProfile } from "../functions/users";
import { db } from "../db";

export const appRouter = createReactiveRouter({ db })
  .addQuery(getUsers)           // Creates: users.getAll (query)
  .addMutation(createUser)      // Creates: users.create (mutation)
  .addQuery(getUserProfile)     // Creates: users.profile.getDetailed (query)
  .build();                     // ‚ö†Ô∏è Don't forget .build()!

export type AppRouter = typeof appRouter;
```

**Custom Names (Optional Override):**
```typescript
const router = createReactiveRouter({ db })
  .addQueryWithName(getUsers, "getAllUsers")  // Override name
  .addQuery(getUserProfile);                   // Uses function name
```

### 4. Database Configuration

```typescript
import { createReactiveDb } from "@agelum/backend/server";
import { drizzle } from "drizzle-orm/postgres-js";

const config = {
  relations: {
    // When these tables change, invalidate related queries
    user: ["profile", "preferences"],
    profile: ["user"],
    preferences: ["user"],
  },
};

export const db = createReactiveDb(drizzle(pool), config);
```

### 4.1 Server Cache (Redis or Memory)

```typescript
const config = {
  relations: {
    user: ["profile", "preferences"],
    profile: ["user"],
    preferences: ["user"],
  },
  cache: {
    server: {
      provider: "redis",
      redis: {
        url: process.env.REDIS_URL,
      },
    },
  },
};

export const db = createReactiveDb(drizzle(pool), config);
```

You can also pass an existing Redis client via `cache.server.redis.client`.

### 5. Client-Side Hooks

```typescript
import { useReactive } from "@agelum/backend/client";

function UserList({ companyId }: { companyId: string }) {
  // Uses the function name as the query key
  const { data: users, isStale, isLoading, error, refetch } = useReactive(
    "users.getAll",
    { companyId, limit: 20 }
  );

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      {isStale && <div className="text-orange-500">Syncing...</div>}
      {users?.map((user) => <UserCard key={user.id} user={user} />)}
    </div>
  );
}
```

**Available Hooks:**
- `useReactive(queryKey, input)` - Main hook for reactive data access
- `useReactiveQuery(queryKey)` - Manual queries with `.run(variables)`
- `useReactiveConnection()` - Get SSE connection status
- `useReactiveStats()` - Session statistics
- `useReactiveRefresh()` - Manual cache refresh

### 6. SSE Setup (Next.js Example)

```typescript
// app/api/events/route.ts
import { createSSEStream } from "@agelum/backend/server";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const organizationId = searchParams.get("organizationId")!;
  return createSSEStream(organizationId);
}

// app/api/events/ack/route.ts (Required for reliable delivery)
import { acknowledgeEvent } from "@agelum/backend/server";

export async function POST(request: Request) {
  const { eventId } = await request.json();
  acknowledgeEvent(eventId);
  return Response.json({ ok: true });
}
```

### 7. Client Provider Setup

```typescript
"use client";
import { TrpcReactiveProvider } from "@agelum/backend/client";
import { createTRPCProxyClient, httpBatchLink } from "@trpc/client";
import type { AppRouter } from "../server/trpc";

const trpcClient = createTRPCProxyClient<AppRouter>({
  links: [httpBatchLink({ url: "/api/trpc" })],
});

export function AppProviders({ children }: { children: React.ReactNode }) {
  const organizationId = "your-organization-id";
  return (
    <TrpcReactiveProvider
      organizationId={organizationId}
      relations={reactiveRelations}
      trpcClient={trpcClient}
    >
      {children}
    </TrpcReactiveProvider>
  );
}
```

## Cache Keys

Client cache keys are automatically composed as `name::JSON(input)`:
- `users.getAll::{"companyId":"123","limit":50}`
- `users.profile.getDetailed::{"userId":"456"}`

Server cache keys for reactive functions default to `name:JSON(input)` and can be customized with `cache.key`.

Access cache key programmatically:
```typescript
const cacheKey = getUsers.getCacheKey({ companyId: "test", limit: 50 });
```
Example value: `users.getAll:{"companyId":"test","limit":50}`

## Function Metadata

```typescript
const metadata = getUsers.getMetadata();
// Returns: {
//   name: "users.getAll",
//   dependencies: ["user"],
//   cacheEnabled: true,
//   cacheTtl: 300,
//   hasInvalidationRules: false,
//   transactionEnabled: false,
//   transactionReplicationMode: undefined
// }
```

## Type-Safe Handler Context

For explicit typing in handlers:

```typescript
import type { ReactiveFunctionContext } from "@agelum/backend/server";
import { z } from "zod";

const getUsersInput = z.object({
  companyId: z.string(),
  limit: z.number().optional(),
});

type GetUsersInput = z.infer<typeof getUsersInput>;

export const getUsers = defineReactiveFunction({
  name: "users.getAll",
  input: getUsersInput,
  dependencies: ["user"],
  handler: async ({ input, db }: ReactiveFunctionContext<GetUsersInput>) => {
    return db.db.query.users.findMany({
      where: (users, { eq }) => eq(users.companyId, input.companyId),
      limit: input.limit ?? 50,
    });
  },
});
```

## Common Patterns

### Mutations with Automatic Cache Invalidation

```typescript
// Server: Define mutation
export const createUser = defineReactiveFunction({
  name: "users.create",
  input: z.object({
    name: z.string(),
    email: z.string().email(),
    companyId: z.string(),
  }),
  dependencies: ["user"],
  handler: async ({ input, db }) => {
    return db.db.insert(users).values(input).returning();
  },
});

// Client: Use mutation (cache invalidation is automatic via SSE)
import { trpc } from "../trpc";

function CreateUserForm({ companyId }: { companyId: string }) {
  const createUserMutation = trpc.users.create.useMutation({
    onSuccess: () => {
      // ‚úÖ Automatic cache invalidation happens via SSE
      // No manual invalidation needed!
    },
  });

  const handleSubmit = (data: FormData) => {
    createUserMutation.mutate({
      name: data.get("name") as string,
      email: data.get("email") as string,
      companyId,
    });
  };

  return <form onSubmit={handleSubmit}>{/* ... */}</form>;
}
```

### Priority Hints for Better UX

```typescript
import { useReactivePriorities } from "@agelum/backend/client";

function MyComponent() {
  useReactivePriorities([
    "users.getAll",              // High priority (visible)
    "users.profile.getDetailed", // Medium priority (likely next)
  ]);

  // Component content...
}
```

## Transactions

The library supports database transactions with three flexible approaches. You can use any combination of these depending on your needs.

### Option 1: Declarative Transaction Config (Simplest)

Add `transaction` config to automatically wrap the entire handler in a transaction:

```typescript
export const transferFunds = defineReactiveFunction({
  name: "accounts.transfer",
  input: z.object({
    fromAccountId: z.string(),
    toAccountId: z.string(),
    amount: z.number().positive(),
  }),
  dependencies: ["account", "transaction"],
  
  // Automatically wraps handler in a transaction
  transaction: {
    enabled: true,
    replicationMode: "sync", // Wait for replicas (optional)
  },
  
  handler: async ({ input, db }) => {
    // All operations here run in a single transaction
    await db.db.update(accounts)
      .set({ balance: sql`balance - ${input.amount}` })
      .where(eq(accounts.id, input.fromAccountId));
    
    await db.db.update(accounts)
      .set({ balance: sql`balance + ${input.amount}` })
      .where(eq(accounts.id, input.toAccountId));
    
    return { success: true };
  },
});
```

### Option 2: Manual Drizzle Transactions (Full Control)

Use Drizzle's native transaction API directly in the handler:

```typescript
export const createOrder = defineReactiveFunction({
  name: "orders.create",
  input: z.object({
    userId: z.string(),
    items: z.array(z.object({
      productId: z.string(),
      quantity: z.number(),
    })),
  }),
  dependencies: ["order", "orderItem", "inventory"],
  
  handler: async ({ input, db }) => {
    // Manual transaction with full control
    return await db.db.transaction(async (tx) => {
      const order = await tx.insert(orders)
        .values({ userId: input.userId })
        .returning();
      
      for (const item of input.items) {
        await tx.insert(orderItems).values({
          orderId: order[0].id,
          productId: item.productId,
          quantity: item.quantity,
        });
        
        await tx.update(inventory)
          .set({ stock: sql`stock - ${item.quantity}` })
          .where(eq(inventory.productId, item.productId));
      }
      
      return order[0];
    });
  },
});
```

### Option 3: Context Helper with Replication Control

Use `db.transaction()` for fine-grained control with replication modes:

```typescript
export const createCriticalRecord = defineReactiveFunction({
  name: "records.createCritical",
  input: z.object({
    data: z.string(),
    requiresSync: z.boolean(),
  }),
  dependencies: ["record", "auditLog"],
  
  handler: async ({ input, db }) => {
    // Use db.transaction() helper with replication options
    return await db.transaction(
      {
        replicationMode: input.requiresSync ? "sync" : "async",
      },
      async (tx) => {
        const record = await tx.insert(records)
          .values({ data: input.data })
          .returning();
        
        await tx.insert(auditLog).values({
          action: "CREATE",
          recordId: record[0].id,
          timestamp: new Date(),
        });
        
        return record[0];
      }
    );
  },
});
```

### Replication Modes

For clustered PostgreSQL databases, you can control how transactions wait for replication:

| Mode | PostgreSQL Setting | Behavior |
|------|-------------------|----------|
| `"sync"` | `synchronous_commit = 'remote_apply'` | Waits for replicas to apply the transaction (strong consistency) |
| `"async"` | `synchronous_commit = 'local'` | Returns immediately without waiting (eventual consistency, faster) |
| `undefined` | Database default | Uses whatever the database is configured with |

**When to use each:**
- **`"sync"`**: Critical operations where you need to read-after-write from any replica (e.g., financial transactions, user creation followed by login)
- **`"async"`**: High-throughput operations where eventual consistency is acceptable (e.g., logging, analytics, non-critical updates)

### Combining Options

You can combine Option 1 (declarative) with Option 2 or 3 inside the handler. When `transaction.enabled` is set, the handler runs inside a transaction, and any nested `db.transaction()` calls create savepoints:

```typescript
export const complexOperation = defineReactiveFunction({
  name: "operations.complex",
  input: z.object({ ... }),
  dependencies: ["tableA", "tableB"],
  
  // Outer transaction wrapper
  transaction: { enabled: true },
  
  handler: async ({ input, db }) => {
    // This runs inside the outer transaction
    await db.db.insert(tableA).values({ ... });
    
    // This creates a savepoint within the outer transaction
    try {
      await db.transaction({ replicationMode: "sync" }, async (tx) => {
        await tx.insert(tableB).values({ ... });
        // If this fails, only this savepoint is rolled back
      });
    } catch (error) {
      // Outer transaction continues
    }
    
    return { success: true };
  },
});
```

## Important Rules

1. **Always use `db.db` inside handlers** to access the Drizzle instance
2. **Call `.build()`** when creating tRPC routers
3. **Use correct import paths**: `/server` for server, `/client` for React
4. **Include all dependent tables** in the `dependencies` array
5. **Function names with dots** create nested tRPC procedures (e.g., `"users.profile.getDetailed"`)
6. **Cache keys include serialized input** - same name + different input = different cache entry

## Troubleshooting

### "Reactive client not initialized"
Call `initializeReactiveClient()` or wrap your app in `TrpcReactiveProvider`/`ReactiveProvider`.

### Cache not invalidating
Check that the `dependencies` array includes all tables that affect the query results.

### tRPC procedure not found
Ensure you called `.build()` on the reactive router and the function name matches.
